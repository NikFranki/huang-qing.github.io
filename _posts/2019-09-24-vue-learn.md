---
layout:     post
title:      Learn Vue
subtitle:   
date:       2019-09-24
author:     huangqing
header-img: img/post-bg-technology-stack.jpg
catalog: true
categories: [Vue]
tags:
    - Vue   
---


## 安装

调试工具：Vue Devtools

脚本引入：
+ 直接使用`<script>`:开发版、生产版
+ CDN: jsdelivr \ unpkg \ cdnjs
+ NPM: `npm install vue`

命令行工具（CLI）：
+ `SPA`单页面应用
+ `batteries-included`构建设置
+ 热重载
+ 保存时`lint`校验
+ 生产环境构建版本

构建版本类型：
1. UMD：通过 `<script>` 标签直接用在浏览器中
2. CommonJS: 配合老的打包工具比如 Browserify 或 webpack 1
3. ES Module（基于构建工具）
   + 诸如 `webpack 2` 或 `Rollup` 提供的现代打包工具。
   + ESM 格式被设计为可以被静态分析,打包工具可以利用这一点来进行“`tree-shaking`”并将用不到的代码排除出最终的包。
4. ES Module（基于浏览器）: 用于在现代浏览器中通过 `<script type="module">` 直接导入。

运行时 + 编译器 vs. 只包含运行时:

为运行时版本相比完整版体积要小大约 30%，所以生产环境应该尽可能使用这个版本

开发环境 vs. 生产环境模式：

+ 保留原始的 `process.env.NODE_ENV` 检测，以决定它们应该运行在什么模式下。
+ `UglifyJS` 压缩

CSP环境：有些环境，如 Google Chrome Apps，会强制应用内容安全策略 (CSP)，不能使用 `new Function()` 对表达式求值。这时可以用 CSP 兼容版本。

## 介绍

声明式渲染：

```HTML
<div id="app">
  {{ message }}
</div>    
```

```JAVASCRIPT
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```

指令：`v-`

条件与循环： `v-if` `v-for`

```html
<p v-if="seen">现在你看到我了</p>
```

```html
<li v-for="todo in todos">
    {{ todo.text }}
</li>
```

处理用户输入：`v-on:click`

```html
 <button v-on:click="reverseMessage">反转消息</button>
```

```javascript
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
```

双向绑定：`v-model`

```html
<div id="app-6">
  <p>{{ message }}</p>
  <input v-model="message">
</div>
```

组件化应用构建: 在Vue实例创建前声明

```javascript
Vue.component('todo-item', {
  // todo-item 组件现在接受一个
  // "prop"，类似于一个自定义特性。
  // 这个 prop 名为 todo。
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})
```

```html
<div id="app-7">
  <ol>
    <!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，稍后再
      作详细解释。
    -->
    <todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id"
    ></todo-item>
  </ol>
</div>

```

## Vue实例

实例生命周期钩子：

![](/images/vue/lifecycle.png)

## 模板语法

数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：

```html
<span>Message: {{ msg }}</span>
```

`v-once`指令：执行一次性地插值
```html
<span v-once>这个将不会改变: {{ msg }}</span>
```

`v-html`:原始 HTML
```html
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

`v-bind`:

```html
<button v-bind:disabled="isButtonDisabled">Button</button>
```

对于布尔特性,如果 `isButtonDisabled` 的值是 `null`、`undefined` 或 `false`，则 `disabled` 特性甚至不会被包含在渲染出来的 `<button>` 元素中。

动态参数：

```html
<!--
注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。
-->
<a v-bind:[attributeName]="url"> ... </a>
```

这里的 `attributeName` 会被作为一个 `JavaScript` 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 `Vue` 实例有一个 `data` 属性 `attributeName，其值为` "`href`"，那么这个绑定将等价于 `v-bind:href`。

同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：
```html
<a v-on:[eventName]="doSomething"> ... </a>
```

修饰符：修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀

```html
<form v-on:submit.prevent="onSubmit">...</form>
```

缩写:

`v-bind` -> `:`

`v-on` -> `@`


## 计算属性和侦听器

对于任何复杂逻辑，你都应当使用计算属性:

```javascript
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：
```javascript
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```

侦听器:`watch`

当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。
```html
<div id="watch-example">
  <p>
    Ask a yes/no question:
    <input v-model="question">
  </p>
  <p>{{ answer }}</p>
</div>
```

```html
<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script>
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
  created: function () {
    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
    // 请参考：https://lodash.com/docs#debounce
    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
  },
  methods: {
    getAnswer: function () {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Questions usually contain a question mark. ;-)'
        return
      }
      this.answer = 'Thinking...'
      var vm = this
      axios.get('https://yesno.wtf/api')
        .then(function (response) {
          vm.answer = _.capitalize(response.data.answer)
        })
        .catch(function (error) {
          vm.answer = 'Error! Could not reach the API. ' + error
        })
    }
  }
})
</script>
```

## Class 与 Style 绑定

对象语法：

我们可以传给 `v-bind:class` 一个对象，以动态地切换 class：

```html
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```

```json
data: {
  isActive: true,
  hasError: false
}
```

```html
<div class="static active"></div>
```

上面的语法表示 `active` 这个 class 存在与否将取决于数据属性 `isActive` 的 truthiness。

绑定的数据对象不必内联定义在模板里：

```html
<div v-bind:class="classObject"></div>
```

```jsonu
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
```